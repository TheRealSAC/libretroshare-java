/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package net.retroshare;

public class ChunkMap {
  private long swigCPtr;
  protected boolean swigCMemOwn;

  protected ChunkMap(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(ChunkMap obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        RetroshareJNI.delete_ChunkMap(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  public ChunkMap(java.math.BigInteger file_size, boolean assume_availability) {
    this(RetroshareJNI.new_ChunkMap(file_size, assume_availability), true);
  }

  public boolean getDataChunk(SWIGTYPE_p_std__string peer_id, long size_hint, ftChunk chunk, SWIGTYPE_p_bool source_chunk_map_needed) {
    return RetroshareJNI.ChunkMap_getDataChunk(swigCPtr, this, SWIGTYPE_p_std__string.getCPtr(peer_id), size_hint, ftChunk.getCPtr(chunk), chunk, SWIGTYPE_p_bool.getCPtr(source_chunk_map_needed));
  }

  public void dataReceived(java.math.BigInteger c_id) {
    RetroshareJNI.ChunkMap_dataReceived(swigCPtr, this, c_id);
  }

  public void setStrategy(FileChunksInfo.ChunkStrategy s) {
    RetroshareJNI.ChunkMap_setStrategy(swigCPtr, this, s.swigValue());
  }

  public FileChunksInfo.ChunkStrategy getStrategy() {
    return FileChunksInfo.ChunkStrategy.swigToEnum(RetroshareJNI.ChunkMap_getStrategy(swigCPtr, this));
  }

  public void getAvailabilityMap(CompressedChunkMap cmap) {
    RetroshareJNI.ChunkMap_getAvailabilityMap(swigCPtr, this, CompressedChunkMap.getCPtr(cmap), cmap);
  }

  public void setAvailabilityMap(CompressedChunkMap cmap) {
    RetroshareJNI.ChunkMap_setAvailabilityMap(swigCPtr, this, CompressedChunkMap.getCPtr(cmap), cmap);
  }

  public void removeFileSource(SWIGTYPE_p_std__string peer_id) {
    RetroshareJNI.ChunkMap_removeFileSource(swigCPtr, this, SWIGTYPE_p_std__string.getCPtr(peer_id));
  }

  public static void buildPlainMap(java.math.BigInteger size, CompressedChunkMap map) {
    RetroshareJNI.ChunkMap_buildPlainMap(size, CompressedChunkMap.getCPtr(map), map);
  }

  public static long getNumberOfChunks(java.math.BigInteger size) {
    return RetroshareJNI.ChunkMap_getNumberOfChunks(size);
  }

  public boolean isChunkAvailable(java.math.BigInteger offset, long chunk_size) {
    return RetroshareJNI.ChunkMap_isChunkAvailable(swigCPtr, this, offset, chunk_size);
  }

  public void removeInactiveChunks(SWIGTYPE_p_std__vectorT_unsigned_long_long_t to_remove) {
    RetroshareJNI.ChunkMap_removeInactiveChunks(swigCPtr, this, SWIGTYPE_p_std__vectorT_unsigned_long_long_t.getCPtr(to_remove));
  }

  public void setPeerAvailabilityMap(SWIGTYPE_p_std__string peer_id, CompressedChunkMap peer_map) {
    RetroshareJNI.ChunkMap_setPeerAvailabilityMap(swigCPtr, this, SWIGTYPE_p_std__string.getCPtr(peer_id), CompressedChunkMap.getCPtr(peer_map), peer_map);
  }

  public SourceChunksInfo getSourceChunksInfo(SWIGTYPE_p_std__string peer_id) {
    long cPtr = RetroshareJNI.ChunkMap_getSourceChunksInfo(swigCPtr, this, SWIGTYPE_p_std__string.getCPtr(peer_id));
    return (cPtr == 0) ? null : new SourceChunksInfo(cPtr, false);
  }

  public java.math.BigInteger getTotalReceived() {
    return RetroshareJNI.ChunkMap_getTotalReceived(swigCPtr, this);
  }

  public boolean isComplete() {
    return RetroshareJNI.ChunkMap_isComplete(swigCPtr, this);
  }

  public void getChunksInfo(FileChunksInfo info) {
    RetroshareJNI.ChunkMap_getChunksInfo(swigCPtr, this, FileChunksInfo.getCPtr(info), info);
  }

  public void setChunkCheckingResult(long chunk_number, boolean succeed) {
    RetroshareJNI.ChunkMap_setChunkCheckingResult(swigCPtr, this, chunk_number, succeed);
  }

  public void getChunksToCheck(SWIGTYPE_p_std__vectorT_unsigned_int_t chunks_to_ask) {
    RetroshareJNI.ChunkMap_getChunksToCheck(swigCPtr, this, SWIGTYPE_p_std__vectorT_unsigned_int_t.getCPtr(chunks_to_ask));
  }

  public void getSourcesList(long chunk_number, SWIGTYPE_p_std__vectorT_std__string_t sources) {
    RetroshareJNI.ChunkMap_getSourcesList(swigCPtr, this, chunk_number, SWIGTYPE_p_std__vectorT_std__string_t.getCPtr(sources));
  }

  public void forceCheck() {
    RetroshareJNI.ChunkMap_forceCheck(swigCPtr, this);
  }

  public void updateTotalDownloaded() {
    RetroshareJNI.ChunkMap_updateTotalDownloaded(swigCPtr, this);
  }

  public final static long CHUNKMAP_FIXED_CHUNK_SIZE = RetroshareJNI.ChunkMap_CHUNKMAP_FIXED_CHUNK_SIZE_get();
}
